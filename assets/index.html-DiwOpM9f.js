import{_ as t,c as a,a as r,o}from"./app-DMdwLNUM.js";const n={};function p(c,e){return o(),a("div",null,e[0]||(e[0]=[r('<h2 id="新增员工" tabindex="-1"><a class="header-anchor" href="#新增员工"><span>新增员工</span></a></h2><h3 id="dto" tabindex="-1"><a class="header-anchor" href="#dto"><span>DTO</span></a></h3><p>通过查看接口文档和项目原型，设计 DTO 类。</p><blockquote><p><strong>DTO</strong>：Data Transfer Object，数据传输对象，主要用于各个层之间传输数据。 当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据</p></blockquote><p>DTO 一般会通过 <strong>Lombok</strong> 的 <code>@Data</code> 注解自动生成 getter、setter 和 toString 方法，非常方便。</p><blockquote><p>Lombok 其实就是一个 Java 库，它可以自动插入到编辑器和构建工具中，增强java的性能。以后你只需要一些简单的注解，就可以再也不用在类中反复去写get、equals等方法。</p></blockquote><h3 id="controller" tabindex="-1"><a class="header-anchor" href="#controller"><span>Controller</span></a></h3><blockquote><p><strong>Controller层</strong>是应用程序的入口点，主要负责<strong>接收用户请求并返回响应</strong>。它的主要职责包括： 处理前端发送的请求，并与后端服务进行交互。 调用Service层的方法来处理业务逻辑，并将结果返回给前端。 负责具体的业务模块流程的控制，调用Service层的接口来控制业务流程。 在具体项目中，Controller层会调用Service层的方法，Service层再调用Dao层中的方法。 通过这种方式，Controller层确保了前后端的有效交互和业务逻辑的处理。</p></blockquote><p>Controller 层因为处理前端的请求，就会用到 Spring 里面的 <code>@PostMapping</code> <code>@GetMapping</code> <code>RequestMapping</code> 等注解，而且函数参数会写 <code>@RequestBody</code> 这样的注解来把请求绑定到 DTO 上，具体可以看 Spring 官网的 Guide。</p><h3 id="service-层" tabindex="-1"><a class="header-anchor" href="#service-层"><span>Service 层</span></a></h3><blockquote><p><strong>Service层</strong>主要负责业务逻辑的处理和管理。它位于 Controller 层和 DAO 层之间，起到连接用户请求和数据访问的桥梁作用。</p></blockquote><p>一般来说有一个 Service 层接口和一个 ServiceImpl 的实现。Service 将 DTO 作为参数，处理例如 save、remove 等业务逻辑。</p><h3 id="mapper-层" tabindex="-1"><a class="header-anchor" href="#mapper-层"><span>Mapper 层</span></a></h3><blockquote><p>Mapper 层的主要职责是执行 SQL 语句，进行数据库的增删改查操作。Mapper 层通常与 DAO（Data Access Object）层相对应，有时两者是合并在一起使用的。Mapper 层的方法会被Service层所调用。</p></blockquote><blockquote><p>关于以上几层的详细讲解可以看这篇博客：<a href="https://blog.csdn.net/qq_38129062/article/details/88967217" target="_blank" rel="noopener noreferrer">Dao层，Mapper层，controller层，service层，model层都有什么作用</a>。</p></blockquote><p>Mapper 这里就很经常用到 Mybatis 了，黑马的源代码里面就使用了 <code>@Insert</code> 注解。</p><h3 id="相关问题" tabindex="-1"><a class="header-anchor" href="#相关问题"><span>相关问题</span></a></h3><p>JWT 令牌：联调的时候发现有问题，发现是没有给 JWT 令牌导致 JwtTokenAdminInterceptor 拒绝了请求。解决方法是 ApiFox 加上全局变量。JWT 相关的知识点之后讲。</p><p>注册重复名字的用户没有抛出异常：那就往异常处理器里面添加相关的异常处理逻辑。</p><p>如何知道当前操作人是谁：解析 JWT 令牌出当前操作人的编号，利用线程资源共享的特点，往 ThreadLocal 里塞操作人编号，然后 Service 层读取这个编号就可以了。</p><h2 id="员工分页查询" tabindex="-1"><a class="header-anchor" href="#员工分页查询"><span>员工分页查询</span></a></h2><h3 id="开发过程" tabindex="-1"><a class="header-anchor" href="#开发过程"><span>开发过程</span></a></h3><p>这里请求参数类型为 Query，不是json格式，在路径后直接拼接：`/admin/employee/page?name=zhangsan</p><p>跟新增员工一样，先处理 DTO 层（黑马已经弄好了），然后处理 common 模块的分页对象和 Result 对象，其次在 Controller 里面处理前端响应，通过 DTO 返回给 Service 层。</p><p>详情可以看黑马的讲义，这里不赘述。</p><h3 id="相关问题-1" tabindex="-1"><a class="header-anchor" href="#相关问题-1"><span>相关问题</span></a></h3><p>返回的 json 的时间字段格式有问题：在 WebMvcConfiguration 中扩展 Spring MVC 的消息转换器，统一对日期类型进行格式处理。</p><h2 id="启用禁用员工账号" tabindex="-1"><a class="header-anchor" href="#启用禁用员工账号"><span>启用禁用员工账号</span></a></h2><h3 id="开发过程-1" tabindex="-1"><a class="header-anchor" href="#开发过程-1"><span>开发过程</span></a></h3><p>先加 Controller，然后修改 Service 和 Mapper，此处不再赘述。</p><p>后面都是一样的，甚至菜品代码直接给出来了，实现都是一模一样的，都不再赘述。</p>',31)]))}const s=t(n,[["render",p]]),l=JSON.parse('{"path":"/article/sky-takeout-2/","title":"苍穹外卖 | Day 2 员工与菜品业务逻辑","lang":"zh-CN","frontmatter":{"title":"苍穹外卖 | Day 2 员工与菜品业务逻辑","createTime":"2025/07/11 20:16:48","permalink":"/article/sky-takeout-2/","description":"新增员工 DTO 通过查看接口文档和项目原型，设计 DTO 类。 DTO：Data Transfer Object，数据传输对象，主要用于各个层之间传输数据。 当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据 DTO 一般会通过 Lombok 的 @Data 注解自动生成 getter、setter 和 toString 方法...","head":[["meta",{"property":"og:url","content":"https://github.com/MrSibe/MrSibe.github.io/article/sky-takeout-2/"}],["meta",{"property":"og:site_name","content":"西贝的博客"}],["meta",{"property":"og:title","content":"苍穹外卖 | Day 2 员工与菜品业务逻辑"}],["meta",{"property":"og:description","content":"新增员工 DTO 通过查看接口文档和项目原型，设计 DTO 类。 DTO：Data Transfer Object，数据传输对象，主要用于各个层之间传输数据。 当前端提交的数据和实体类中对应的属性差别比较大时，建议使用DTO来封装数据 DTO 一般会通过 Lombok 的 @Data 注解自动生成 getter、setter 和 toString 方法..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T03:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T03:18:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"苍穹外卖 | Day 2 员工与菜品业务逻辑\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-14T03:18:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.27,"words":981},"git":{"updatedTime":1757819922000,"contributors":[{"name":"xibei","username":"xibei","email":"15281741661@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/xibei?v=4","url":"https://github.com/xibei"}]},"autoDesc":true,"filePathRelative":"computer/苍穹外卖/sky-takeout-2.md","categoryList":[{"id":"df53ca","sort":10002,"name":"computer"},{"id":"5542b4","sort":10003,"name":"苍穹外卖"}]}');export{s as comp,l as data};
