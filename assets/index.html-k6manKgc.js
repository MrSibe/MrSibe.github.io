import{_ as s,c as e,a,o as t}from"./app-DMdwLNUM.js";const n={};function h(r,i){return t(),e("div",null,i[0]||(i[0]=[a('<h2 id="extends" tabindex="-1"><a class="header-anchor" href="#extends"><span>Extends</span></a></h2><p>之前我们是通过 interface 进行继承关系的设置的。Interface 定义了子类可以做什么，实现了一种契约。这节课我们介绍继承关系的另外一种：extends，它实现两个类之间的继承关系，子类继承父类的成员，并且可以有所修改。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> RotatingSLList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Item</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> extends</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> SLList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Item</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在定义类的时候，后面跟着 extends 关键词，再加上父类就可以啦。</p><p>继承的成员包括：</p><ol><li>所有的实例和静态变量</li><li>所有的方法</li><li>所有的内置类</li></ol><p>注意，构造器是不能继承的，private 成员也是不能直接访问的。</p><h2 id="构造器是不能继承的" tabindex="-1"><a class="header-anchor" href="#构造器是不能继承的"><span>构造器是不能继承的</span></a></h2><p>有个问题是构造器为什么不能继承。</p><p>这是因为在 Java 中，所有的构造开头必须调用所有的父类构造器（通过在构造器开头加入 super 方法）。要是构造器可以继承，就重复了。</p><h2 id="object-类" tabindex="-1"><a class="header-anchor" href="#object-类"><span>Object 类</span></a></h2><p>万类之母——Object。</p><p>所有的类都是 Object 的子类。它有 <code>.equals(Object obj)</code>、<code>.hashCode()</code> 和 <code>toString()</code> 方法。</p><h2 id="封装" tabindex="-1"><a class="header-anchor" href="#封装"><span>封装</span></a></h2><p>OOP 编程有个最重要的敌人是复杂性。我们要学会让程序不那么复杂，或者说程序员写代码不需要考虑太多。</p><p>有一个方法可以很好管理复杂性，就是封装。封装的含义是，让外界无法访问类内部的成员，而是只能通过类提供的方法（或者说接口）来实现一些操作。</p><p>这样就可以不管一个类内部怎么实现的，只需要调用类提供的方法，实现功能即可，就很简单了。</p><h2 id="类型验证和强制转换" tabindex="-1"><a class="header-anchor" href="#类型验证和强制转换"><span>类型验证和强制转换</span></a></h2><p>上节课我们讲过，当子类覆盖了父类的方法等时候，Java 会根据动态类型来确定运行采用什么方法。因此动态类型也被称为运行时类型。而在正常状况的时候，编译器则通过静态变量来确定，因此静态变量也称为编译时类型。</p><h3 id="表达式" tabindex="-1"><a class="header-anchor" href="#表达式"><span>表达式</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">SLList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> sl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> VengefulSLList</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这样的有 new 的语句我们都叫它表达式。表达式也是含有编译时类型的。</p><p>确定表达式的编译时类型，我们需要往右看，new 的类型即编译时类型。</p><h3 id="类型转换" tabindex="-1"><a class="header-anchor" href="#类型转换"><span>类型转换</span></a></h3><p>有的时候我们希望告诉编译器，这个实例的编译时类型是 xx 类型，这种情况可以用类型转换。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Poodle</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> largerPoodle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Poodle</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> maxDog</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">frank</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> frankJr</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="higher-order-functions" tabindex="-1"><a class="header-anchor" href="#higher-order-functions"><span>Higher Order Functions</span></a></h2><p>一般的函数都是传数据，但有一种特别的函数，可以往它的参数列表传函数名。这样的函数我们叫 Higher Order Functions。</p>',28)]))}const d=s(n,[["render",h]]),p=JSON.parse('{"path":"/CS_61B/xlghaz2f/","title":"9. Extends, Casting, Higher Order Functions","lang":"zh-CN","frontmatter":{"title":"9. Extends, Casting, Higher Order Functions","createTime":"2025/05/10 17:00:25","permalink":"/CS_61B/xlghaz2f/","description":"Extends 之前我们是通过 interface 进行继承关系的设置的。Interface 定义了子类可以做什么，实现了一种契约。这节课我们介绍继承关系的另外一种：extends，它实现两个类之间的继承关系，子类继承父类的成员，并且可以有所修改。 在定义类的时候，后面跟着 extends 关键词，再加上父类就可以啦。 继承的成员包括： 所有的实例和静...","head":[["meta",{"property":"og:url","content":"https://github.com/MrSibe/MrSibe.github.io/CS_61B/xlghaz2f/"}],["meta",{"property":"og:site_name","content":"西贝的博客"}],["meta",{"property":"og:title","content":"9. Extends, Casting, Higher Order Functions"}],["meta",{"property":"og:description","content":"Extends 之前我们是通过 interface 进行继承关系的设置的。Interface 定义了子类可以做什么，实现了一种契约。这节课我们介绍继承关系的另外一种：extends，它实现两个类之间的继承关系，子类继承父类的成员，并且可以有所修改。 在定义类的时候，后面跟着 extends 关键词，再加上父类就可以啦。 继承的成员包括： 所有的实例和静..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T03:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T03:18:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"9. Extends, Casting, Higher Order Functions\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-14T03:18:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":2.32,"words":695},"git":{"updatedTime":1757819922000,"contributors":[{"name":"xibei","username":"xibei","email":"15281741661@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/xibei?v=4","url":"https://github.com/xibei"}]},"autoDesc":true,"filePathRelative":"notes/CS-61B/CS_61B_9.md"}');export{d as comp,p as data};
