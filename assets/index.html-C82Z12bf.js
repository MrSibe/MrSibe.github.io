import{_ as t,c as n,a as o,o as i}from"./app-DMdwLNUM.js";const c={};function a(p,e){return i(),n("div",null,e[0]||(e[0]=[o('<h2 id="不相交集合" tabindex="-1"><a class="header-anchor" href="#不相交集合"><span>不相交集合</span></a></h2><p>如果两个集合没有公共元素，则称它们为不相交集合。并集（或并查集）数据结构用于跟踪固定数量的元素，这些元素被划分为若干个不相交的集合。</p><p>Disjoint sets 类有两个方法：</p><ol><li><code>connect(int p, int q)</code>：把两个元素合并起来，成为一个。</li><li><code>isConnected(int p, int q)</code>：判断两个元素是否属于同一个并集。</li></ol><p>接下来我们讲四种实现方式：</p><h2 id="快速查找" tabindex="-1"><a class="header-anchor" href="#快速查找"><span>快速查找</span></a></h2><p><code>connect</code> 方法要首先在 List 中遍历，查找 <code>p</code> 和 <code>q</code>，这样会很慢: O(n)。因此我们先用快速查找优化一下查找方法。</p><p>我们规定：建立一个数组，数组的下标对应指定的数字，而数组对应的值是这个数字所属的集合编号。</p><p>这样规定之后，<code>connect</code> 方法就是把下标对应的值改成集合编号，而 <code>isConnected</code> 方法则是判断两个下标对应的值是否相等。这样做到的时间复杂度为 O(1)；</p><h2 id="快速联合" tabindex="-1"><a class="header-anchor" href="#快速联合"><span>快速联合</span></a></h2><p>这一部分主要是让几个集合连接在一起，成为一个集合。这里还是用数组实现。</p><p>我们假想一个集合是一颗树，集合的根对应的数字，其值为-1；剩下的数字的值，是父节点的数字。</p><p>此外我们还需要定义一个 find 函数，来查找某个数字对应的集合的根是谁。</p><p>这样规定之后，<code>connect</code> 方法就是把使得 <code>find(p) = find(q)</code> ，而 <code>isConnected</code> 方法则是判断 <code>find(p) == find(q)</code>。这样做到的时间复杂度为 O (1)；</p><h2 id="加权快速联合-wqu" tabindex="-1"><a class="header-anchor" href="#加权快速联合-wqu"><span>加权快速联合（WQU）</span></a></h2>',15)]))}const d=t(c,[["render",a]]),r=JSON.parse('{"path":"/CS_61B/l3esum9o/","title":"14. Disjoint Sets","lang":"zh-CN","frontmatter":{"title":"14. Disjoint Sets","createTime":"2025/05/22 20:42:47","permalink":"/CS_61B/l3esum9o/","description":"不相交集合 如果两个集合没有公共元素，则称它们为不相交集合。并集（或并查集）数据结构用于跟踪固定数量的元素，这些元素被划分为若干个不相交的集合。 Disjoint sets 类有两个方法： connect(int p, int q)：把两个元素合并起来，成为一个。 isConnected(int p, int q)：判断两个元素是否属于同一个并集。 接...","head":[["meta",{"property":"og:url","content":"https://github.com/MrSibe/MrSibe.github.io/CS_61B/l3esum9o/"}],["meta",{"property":"og:site_name","content":"西贝的博客"}],["meta",{"property":"og:title","content":"14. Disjoint Sets"}],["meta",{"property":"og:description","content":"不相交集合 如果两个集合没有公共元素，则称它们为不相交集合。并集（或并查集）数据结构用于跟踪固定数量的元素，这些元素被划分为若干个不相交的集合。 Disjoint sets 类有两个方法： connect(int p, int q)：把两个元素合并起来，成为一个。 isConnected(int p, int q)：判断两个元素是否属于同一个并集。 接..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T03:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T03:18:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"14. Disjoint Sets\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-14T03:18:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":1.45,"words":434},"git":{"updatedTime":1757819922000,"contributors":[{"name":"xibei","username":"xibei","email":"15281741661@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/xibei?v=4","url":"https://github.com/xibei"}]},"autoDesc":true,"filePathRelative":"notes/CS-61B/CS_61B_14.md"}');export{d as comp,r as data};
