import{_ as a,c as i,a as n,o as e}from"./app-DMdwLNUM.js";const l={};function p(d,s){return e(),i("div",null,s[0]||(s[0]=[n(`<h2 id="一点点进制知识" tabindex="-1"><a class="header-anchor" href="#一点点进制知识"><span>一点点进制知识</span></a></h2><p>二进制、十进制、十六进制</p><h2 id="命令行编译" tabindex="-1"><a class="header-anchor" href="#命令行编译"><span>命令行编译</span></a></h2><p>javac 编译器首先把 java 文件编译成 class 字节码文件</p><p>java 解释器随后执行 class 字节码。</p><p>Intellij IDEA 这个 IDE 把两个过程隐藏成了一步。</p><h2 id="main-函数的秘密" tabindex="-1"><a class="header-anchor" href="#main-函数的秘密"><span>main 函数的秘密</span></a></h2><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> ArgsDemo</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">/** Prints out the 0th command line argument. */</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">	public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> main</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">		System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">args</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">0</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">	}</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现 main 函数的参数列表总是有个 <code>String[] args</code>，这到底是干嘛的。执行上面的程序你就知道了。</p><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">$</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> java</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> ArgsDemo</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> hello</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> some</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;"> args</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">hello</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>懂了吗？这个参数列表的传递靠的是命令行。</p><h2 id="git" tabindex="-1"><a class="header-anchor" href="#git"><span>Git</span></a></h2><p>我们经常用 Git 作为版本管理工具，接下来要补充一些 git 的知识。</p><p>Git 是用 C 语言编写的。我们在命令行里执行 <code>git</code> 命令就可以运行 git 程序，而不是 <code>java git</code>，这是因为 C 语言编译出的二进制文件可以直接由计算机执行，而不像 java 还需要一个 Java 解释器。</p><p>Git 程序运行传递参数是通过 C 语言中的 <code>const char **argv</code> 实现的，这跟 Java 的 <code>String[] args</code> 是一样的。</p><p>Git 的 main 函数传递的 <code>argv</code> 指针随后被调用到 <code>cmd_main</code> 函数了。</p><p>Git 是个非常复杂的程序，还用到了很多我们还没有学到的知识。比如说 maps、hashing、I/O 和 graphs。</p><p>对了，现在我们给大家讲 Git 是因为，proj 2 要自己实现一个 git，叫做 gitlet。</p><h2 id="基础的-git-功能" tabindex="-1"><a class="header-anchor" href="#基础的-git-功能"><span>基础的 Git 功能</span></a></h2><h3 id="为什么需要版本管理" tabindex="-1"><a class="header-anchor" href="#为什么需要版本管理"><span>为什么需要版本管理</span></a></h3><p>软件开发是个不断迭代的过程，版本管理主要有下面两个好处：</p><ul><li>多人协作的时候，可以确保自己的代码不会干扰别人的工作。</li><li>单人工作的时候，可能会进行一些复杂的改动，我们需要随时退回之前的版本。</li></ul><h3 id="最简单的版本管理" tabindex="-1"><a class="header-anchor" href="#最简单的版本管理"><span>最简单的版本管理</span></a></h3><p>我们平时工作最常见的版本管理就是，把源代码拷贝一份，改名为 xxx 第二版、第三版...</p><p>这样虽然很简单，但是会带来许多缺点：</p><ul><li>浪费空间</li><li>恢复到原来的代码很复杂</li><li>需要经常备份</li><li>如果要把两个备份合并在一起很困难</li></ul><p>因此，为了解决这些问题，出现了很多版本管理工具。</p><h3 id="版本管理软件" tabindex="-1"><a class="header-anchor" href="#版本管理软件"><span>版本管理软件</span></a></h3><p>近些年出现了很多版本管理软件：</p><ul><li>Git (2005, open source)</li><li>Perforce (1995)</li><li>SVN (2000, open source)</li><li>Mercurial (2005, open source)</li></ul><p>其中，git 是最出名的一个。</p><h3 id="git-是如何工作的" tabindex="-1"><a class="header-anchor" href="#git-是如何工作的"><span>Git 是如何工作的</span></a></h3><p>每次当我们 commit 改动的时候，git 把整个项目都保存到了一个隐藏起来的文件夹：<code>.git</code></p><p>但是有个问题：假如每次都把项目复制一份，那么 <code>.git</code> 文件夹会越来越大，越来越冗余。为了解决这种冗余，我们会有很多小点子来解决它。</p><h2 id="避免冗余" tabindex="-1"><a class="header-anchor" href="#避免冗余"><span>避免冗余</span></a></h2><h3 id="考虑下面的场景" tabindex="-1"><a class="header-anchor" href="#考虑下面的场景"><span>考虑下面的场景</span></a></h3><p>假如说我们接下来会有三个 commits：</p><ul><li>V1: 创建 readme.txt。</li><li>V2: 创建 utils/Utils.java，game/Game.java，sgame/Test.java。修改 readme。</li><li>V3: 修改 game/Game.java，readme.txt 回退到 V1。</li></ul><h3 id="方法一-对整个项目都存储一次备份" tabindex="-1"><a class="header-anchor" href="#方法一-对整个项目都存储一次备份"><span>方法一：对整个项目都存储一次备份</span></a></h3><p><code>commit</code> 操作，只需要在 <code>.git</code> 文件夹下面创立一个子文件夹，名为 V1 等等，然后把整个项目拷贝进去就行。</p><p><code>checkout</code> 操作，只需要把当前文件夹下的所有东西删除，然后把目标子文件夹下的所有文件拷贝过来就行。</p><p>但是这样的方法效率很低。</p><h3 id="方法二-子文件夹只存储修改了的文件" tabindex="-1"><a class="header-anchor" href="#方法二-子文件夹只存储修改了的文件"><span>方法二：子文件夹只存储修改了的文件</span></a></h3><p>创建多个版本子文件夹，每个版本文件夹只存储修改的文件。</p><ul><li>这个方法会更加高效。</li><li>但是 <code>checkout</code> 操作会很复杂。为了切换到某个版本，我们需要在各个子文件夹中把文件拷贝过来，也很麻烦。</li></ul><p>举个例子：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>.git/v1/Hello.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v2/Hello.java</span></span>
<span class="line"><span>.git/v2/Friend.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v3/Friend.java</span></span>
<span class="line"><span>.git/v3/Egg.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v4/Friend.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v5/Hello.java</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面是 version 1 到 version 5 的记录。如果我们从 version 5 切换到 version 4，我们会需要哪些文件？</p><p>我们需要 v2 的 <code>Hello.java</code>，v4 的 <code>Friend.java</code> 以及 v3 的 <code>Egg.java</code>，这里可以用以下方法来表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V4: Hello.java → v2, Friend.java → v4, Egg.java → v3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这和 map 或者说是字典这样的数据结构很类似。</p><h3 id="方法三-在方法二上添加数据结构" tabindex="-1"><a class="header-anchor" href="#方法三-在方法二上添加数据结构"><span>方法三：在方法二上添加数据结构</span></a></h3><p>基于上面的数据结构，我们改进一下表示方法：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>.git/v1/Hello.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v2/Hello.java</span></span>
<span class="line"><span>.git/v2/Friend.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v3/Friend.java</span></span>
<span class="line"><span>.git/v3/Egg.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v4/Friend.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v5/Hello.java</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>对于上面的版本管理文件夹，我们可以换成一下方法表示：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V1: Hello.java → v1</span></span>
<span class="line"><span>V2: Hello.java → v2, Friend.java → v2</span></span>
<span class="line"><span>V3: Hello.java → v2, Friend.java → v2, Egg.java → v3</span></span>
<span class="line"><span>V4: Hello.java → v2, Friend.java → v4, Egg.java → v3</span></span>
<span class="line"><span>V5: Hello.java → v5, Friend.java → v4, Egg.java → v3</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面做一个练习题：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>.git/v1/X.java</span></span>
<span class="line"><span>.git/v1/Y.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v2/Y.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v3/Z.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v4/X.java</span></span>
<span class="line"><span>.git/v4/A.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/v5/X.java</span></span>
<span class="line"><span>.git/v5/Y.java</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们切换到 v4，我们需要拷贝哪些文件？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V4: X.java → v4, Y.java → v2, Z.java → v3, A.java → v4</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这就很明确了。</p><p>采用字典这样管理版本的方法，还有一个好处是，假如说上面的 v5 的 X.java 跟 v1 一样，X.java 直接就指向 v1 了。</p><h2 id="用-hashing-消除冗余" tabindex="-1"><a class="header-anchor" href="#用-hashing-消除冗余"><span>用 hashing 消除冗余</span></a></h2><h3 id="方法四-把时间作为版本号" tabindex="-1"><a class="header-anchor" href="#方法四-把时间作为版本号"><span>方法四：把时间作为版本号</span></a></h3><p>现在来个新的例子。我们把版本号改成时间日期试一试：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>.git/02_16_2021_03_29_45/X.java</span></span>
<span class="line"><span>.git/02_16_2021_03_29_45/Y.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/02_16_2021_11_29_45/Y.java</span></span>
<span class="line"><span>.git/02_16_2021_11_29_45/Z.java</span></span>
<span class="line"><span></span></span>
<span class="line"><span>.git/02_16_2021_13_29_45/X.java</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>表示方法如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span>V02_16_2021_03_29_45:</span></span>
<span class="line"><span>- X.java → 02_16_2021_03_29_45</span></span>
<span class="line"><span>- Y.java → 02_16_2021_03_29_45</span></span>
<span class="line"><span>V02_16_2021_11_29_45:</span></span>
<span class="line"><span>- X.java → 02_16_2021_03_29_45</span></span>
<span class="line"><span>- Y.java → 02_16_2021_11_29_45</span></span>
<span class="line"><span>- Z.java → 02_16_2021_11_29_45</span></span>
<span class="line"><span>V02_16_2021_13_29_45: </span></span>
<span class="line"><span>- X.java → 02_16_2021_13_29_45</span></span>
<span class="line"><span>- Y.java → 02_16_2021_11_29_45</span></span>
<span class="line"><span>- Z.java → 02_16_2021_11_29_45</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这样有个问题：假如有两个程序员都在修改，一个修改并提交了 <code>Horse.java</code>，另一个修改并提交了 <code>Fish.java</code>，这种情况，这个方法就会失效。</p><h3 id="方法五-把哈希值作为版本号" tabindex="-1"><a class="header-anchor" href="#方法五-把哈希值作为版本号"><span>方法五：把哈希值作为版本号</span></a></h3><p>Git 实际上是用 <code>git-SHA1 hash</code> 函数处理文件，并将哈希值作为版本号的。哈希的特点是，两个一模一样的文件，其哈希值是一样的。</p><p><code>Git-SHA1 hash</code> 实际上是由 <code>文件大小</code> + <code>0</code> + <code>文件的SHA1 哈希值</code> 组成的，一共 160 位。</p><p>假如说我们让 git 存储 Hello World 程序：</p><ul><li>首先，git 计算 git-SHA1 哈希值：HelloWorld.java → 66ccdc645c9d156d5c796dbe6ed768430c1562a2</li><li>Git 会创建一个名为 .git/objects/66 的文件夹，66 是 git-SHA1 哈希的前两个字符。</li><li>Git 将内容存储在名为 ccdc645c9d156d5c796dbe6ed768430c1562a2 的文件中。文件以压缩格式 （zlib） 存储以节省空间。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>最后让我们比较一下之前讲的方法：</p><table><thead><tr><th>方法序号</th><th>方法特点</th><th>缺点</th></tr></thead><tbody><tr><td>1，2，3</td><td>用 Version 1 这样的序号提交</td><td>没有中心服务器，无法确定版本先后顺序</td></tr><tr><td>4</td><td>用时间日期提交</td><td>两个人同时提交的时候会出问题</td></tr><tr><td>5</td><td>用哈希值提交</td><td>哈希值可能会碰撞，但是概率极小</td></tr></tbody></table><p>哈希还有一个好处：安全。假如黑客攻击了代码仓库，改动了一个代码，那么其哈希值肯定会改变，git 可以直接检测出来；还有是下载文件的时候可以通过哈希码检验下载的完整性。</p><h2 id="可序列化和存储数据结构" tabindex="-1"><a class="header-anchor" href="#可序列化和存储数据结构"><span>可序列化和存储数据结构</span></a></h2><h3 id="git-commit" tabindex="-1"><a class="header-anchor" href="#git-commit"><span>Git commit</span></a></h3><p>每一个 commit 会包括以下信息：</p><ul><li>作者</li><li>时间日期</li><li>提交信息（commit message）</li><li>所有文件及其版本的列表（文件版本是文件的 git-SHA 1 哈希值）</li><li>父级的 commit ID（commit ID 是整个 commit 的哈希值）</li></ul><p>我们用 Java 代码实现一下一个 commit 类：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Commit</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">   public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> author</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 作者</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">   public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> date</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 提交时间日期</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">   public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> commitMessage</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // commit message</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">   public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> String</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> parentID</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;"> // 父级的commit ID</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">   // 可以理解为父级的 Commit 对象整个都拿去哈希</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">   ...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>还有一件事：这个 commit 对象要作为数据存储下来。Java 内置了一个 Serializable 接口，专门用于存储对象，对象只需要 implements 这个 Serializable 类就可以被存储，而且不需要实现任何方法。然后我们写一个 Utils 类，来负责从文件中读写对象。</p><h2 id="branching" tabindex="-1"><a class="header-anchor" href="#branching"><span>Branching</span></a></h2><h3 id="merging" tabindex="-1"><a class="header-anchor" href="#merging"><span>Merging</span></a></h3><p>版本管理系统还有一个特性：创建分支。</p><p>我们在做项目的时候，可能不会太相信现有的 master 分支很好，打算自己在 master 的基础上写一个新的项目，这个时候就可以自己新建一个分支（branch）。</p><p><code>checkout</code> 命令不仅可以在不同的分支上切换，还可以通过选项 <code>-b</code> ，在某个分支的基础上新建分支。</p><p><code>merge</code> 命令可以把 master 分支与指定的分支进行合并。我们之后自己写 <code>gitlet</code> 程序的时候 merge 命令会是个大难题。而且 merge 之后，整个版本管理不再是链表，而是图了。</p>`,91)]))}const h=a(l,[["render",p]]),r=JSON.parse('{"path":"/CS_61B/w9m8dbc7/","title":"12. Command Line Programming, Git, Project 2 Preview","lang":"zh-CN","frontmatter":{"title":"12. Command Line Programming, Git, Project 2 Preview","createTime":"2025/05/10 17:00:25","permalink":"/CS_61B/w9m8dbc7/","description":"一点点进制知识 二进制、十进制、十六进制 命令行编译 javac 编译器首先把 java 文件编译成 class 字节码文件 java 解释器随后执行 class 字节码。 Intellij IDEA 这个 IDE 把两个过程隐藏成了一步。 main 函数的秘密 我们会发现 main 函数的参数列表总是有个 String[] args，这到底是干嘛的。...","head":[["meta",{"property":"og:url","content":"https://github.com/MrSibe/MrSibe.github.io/CS_61B/w9m8dbc7/"}],["meta",{"property":"og:site_name","content":"西贝的博客"}],["meta",{"property":"og:title","content":"12. Command Line Programming, Git, Project 2 Preview"}],["meta",{"property":"og:description","content":"一点点进制知识 二进制、十进制、十六进制 命令行编译 javac 编译器首先把 java 文件编译成 class 字节码文件 java 解释器随后执行 class 字节码。 Intellij IDEA 这个 IDE 把两个过程隐藏成了一步。 main 函数的秘密 我们会发现 main 函数的参数列表总是有个 String[] args，这到底是干嘛的。..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T03:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T03:18:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"12. Command Line Programming, Git, Project 2 Preview\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-09-14T03:18:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":7.1,"words":2129},"git":{"updatedTime":1757819922000,"contributors":[{"name":"xibei","username":"xibei","email":"15281741661@qq.com","commits":2,"avatar":"https://avatars.githubusercontent.com/xibei?v=4","url":"https://github.com/xibei"}]},"autoDesc":true,"filePathRelative":"notes/CS-61B/CS_61B_12.md"}');export{h as comp,r as data};
