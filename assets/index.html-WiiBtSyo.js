import{_ as e,c as a,a as t,o as n}from"./app-DMdwLNUM.js";const s={};function r(p,i){return n(),a("div",null,i[0]||(i[0]=[t('<h2 id="redis-基础篇" tabindex="-1"><a class="header-anchor" href="#redis-基础篇"><span>Redis 基础篇</span></a></h2><h3 id="数据类型与命令" tabindex="-1"><a class="header-anchor" href="#数据类型与命令"><span>数据类型与命令</span></a></h3><h4 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h4><p>Redis 是个键值数据库，一般来说 Key 是 String 类型，Value 却多种多样：</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250716222752.png" alt=""></p><p>前五种基本类型，后三种特殊类型。</p><h4 id="key-的层级格式" tabindex="-1"><a class="header-anchor" href="#key-的层级格式"><span>Key 的层级格式</span></a></h4><p>有个问题：redis 里面没有表这个概念，那么如何区分员工 id 和商品 id 呢？</p><p><code>项目名:业务名:类型:id</code></p><p>Key 通过 <code>:</code> 形成层级。如果 value 是个 java 对象，可以序列化成 json 格式作为 value。</p><h4 id="通用命令" tabindex="-1"><a class="header-anchor" href="#通用命令"><span>通用命令</span></a></h4><blockquote><p>首先，help 命令可以查看命令的使用方法</p></blockquote><ol><li>KEYS：查找符合模板的所有 key，不建议在生产环境使用</li><li>DEL：删除指定的 key，返回删除成功的数目</li><li>EXIST：判断 key 是否存在，存在返回 1，否则返回 0</li><li>EXPIRE：给 key 设置一个有效期，到期自动删除</li><li>TTL：查看 key 的有效期</li></ol><h4 id="string-类型命令" tabindex="-1"><a class="header-anchor" href="#string-类型命令"><span>String 类型命令</span></a></h4><p>字符串的格式分三类：</p><ul><li>String：普通字符串</li><li>Int：整数类型，可以自加自减</li><li>Float：浮点数类型，可以自加自减</li></ul><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250716225506.png" alt="image.png"></p><h4 id="hash-类型命令" tabindex="-1"><a class="header-anchor" href="#hash-类型命令"><span>Hash 类型命令</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717102503.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103122.png" alt="image.png"></p><h4 id="list-类型与命令" tabindex="-1"><a class="header-anchor" href="#list-类型与命令"><span>List 类型与命令</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103242.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103313.png" alt="image.png"></p><h4 id="set-类型与命令" tabindex="-1"><a class="header-anchor" href="#set-类型与命令"><span>Set 类型与命令</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103443.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103530.png" alt="image.png"></p><h4 id="sortedset-类型与命令" tabindex="-1"><a class="header-anchor" href="#sortedset-类型与命令"><span>SortedSet 类型与命令</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103616.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103638.png" alt="image.png"></p><h3 id="redis-的-java-客户端" tabindex="-1"><a class="header-anchor" href="#redis-的-java-客户端"><span>Redis 的 Java 客户端</span></a></h3><p>客户端有很多种，Redis 官方推荐的三个客户端有 Jedis、lettuce、Redisson，而前两者被 Spring 给整合在 Spring Data Redis 里面了。</p><h4 id="jedis" tabindex="-1"><a class="header-anchor" href="#jedis"><span>Jedis</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717104453.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717104734.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111143.png" alt="image.png"></p><h4 id="spring-data-redis" tabindex="-1"><a class="header-anchor" href="#spring-data-redis"><span>Spring Data Redis</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111343.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111437.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717112018.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717112047.png" alt="image.png"></p><p>但是 RedisTemplate 也有问题：</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113627.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113719.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113922.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113959.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717114037.png" alt="image.png"></p><h2 id="redis-实战篇" tabindex="-1"><a class="header-anchor" href="#redis-实战篇"><span>Redis 实战篇</span></a></h2><p>这一部分主要做黑马点评这个项目，主要特色如下：</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717142948.png" alt="image.png"></p><p>项目安装配置不讲，直接进入项目。</p><h3 id="短信登录" tabindex="-1"><a class="header-anchor" href="#短信登录"><span>短信登录</span></a></h3><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717151142.png" alt="image.png"></p><p>直接在 Controller 里面加上发送验证码、登录请求，然后取 Service 里面写代码。</p><p>主要用到了 RandomUtil 生成验证码和随机用户名。</p><p>后续每次请求需要校验登录状态，为了提高重用率，直接写一个拦截器，实现 <code>HandlerInterceptor</code> 接口，并重写 <code>preHandle</code>，<code>postHandle</code>，<code>afterCompletion</code> 三个方法。拦截的时候记得 <code>response</code> 需要 <code>setStatus</code>。</p><p>MVC 也需要配置，在 config 创建一个 <code>MvcConfig</code> 类实现 <code>WebMvcConfigurer</code>。</p><blockquote><p>这里官方给的代码有大坑： 首先是 UserHolder 泛型类是之后课程才会用的 UserDTO，这里为了让代码跑起来记得改成 User！ 其次是 MvcConfig 类记得加上 @Configuration 注解，不然没放进容器里面，拦截器不生效，用户信息也就放不进 ThreadLocal！</p></blockquote><blockquote><p>服了，这节课才把 UserHolder 改成 User，下节课就要求改回 UserDTO。 顺便讲一下 DTO。DTO 主要用于数据传输。前端不需要 User 类的全部信息（信息敏感），于是就创建一个 DTO 类型抓门传数据给前端。两个类的转换通过 BeanUtil 的 copyProperties 方法。</p></blockquote><p>有时候需要用到多台 Tomcat 容器，每个容器之间的 session 是不共享的，会导致 session 的失效。因此我们需要找一个可以数据共享、键值存储的解决方案，所以我们采用 Redis。</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717180155.png" alt="image.png"></p><p>这里比较麻烦，主要是讲 session 的部分改成 <code>stringRedisTemplate</code> 操作，并且还要自己自定义转换类。</p><p>现在的拦截器有个 bug：假如登录用户一直产生不需要登陆的请求，那么过段时间用户自动就退出登录了（因为这些请求都没过拦截器，TTL 一直没刷新），所以解决方案是：再写一个新的拦截器，判断是不是登录用户，是就刷新 TTL，不是就直接放行。</p><h3 id="商户查询缓存" tabindex="-1"><a class="header-anchor" href="#商户查询缓存"><span>商户查询缓存</span></a></h3><p>缓存是个好东西：一方面它可以给后端减小压力，另一方面可以减小响应时间。但是同时缓存也有成本：如果数据库更新了但是缓存没更新，就会出大问题（数据一致性成本）</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718100836.png" alt="image.png"></p><p>老师提了一个作业，写分类列表的缓存，非常简单这里不过多阐述。</p><p>刚刚讲过数据一致性问题，因此我们需要策略来更新 redis 缓存，优化我们的业务：</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718113615.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718113850.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114056.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114201.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114446.png" alt="image.png"></p><p>这几页 PPT 的思考很多，可以多理解思考过程。</p><p>写操作为了保证原子性，加上了 <code>@Transactional</code> 注解。</p><h4 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718122231.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718122504.png" alt="image.png"></p><h4 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718124422.png" alt="image.png"></p><h4 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132634.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132824.png" alt="image.png"></p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132844.png" alt="image.png"></p><p>之后我们就采用互斥锁来解决缓存击穿问题。我们可以通过 <code>setIfAbsent</code> 函数设置锁。</p><p>获取锁成功之后建议再一次检测一下 redis 缓存，doubleCheck</p><p>做完之后用 JMeter 做压测，大概 458.1 的吞吐量，600 QPS</p><p>接下来又通过逻辑过期实现。</p><h4 id="封装缓存工具" tabindex="-1"><a class="header-anchor" href="#封装缓存工具"><span>封装缓存工具</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718151108.png" alt="image.png"></p><h3 id="优惠卷秒杀" tabindex="-1"><a class="header-anchor" href="#优惠卷秒杀"><span>优惠卷秒杀</span></a></h3><h4 id="全局唯一-id-生成器" tabindex="-1"><a class="header-anchor" href="#全局唯一-id-生成器"><span>全局唯一 id 生成器</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718154008.png" alt="image.png"></p><p>这个 ID 生成器可以借助 Redis 的自增命令实现，同时为了确保安全性再拼接一些其他数据：</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718154601.png" alt="image.png"></p><p>ID 生成一般有一下方法：</p><ul><li>UUID</li><li>Redis 自增</li><li>Snowflake 算法</li><li>数据库自增</li></ul><h4 id="秒杀下单" tabindex="-1"><a class="header-anchor" href="#秒杀下单"><span>秒杀下单</span></a></h4><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718163335.png" alt="image.png"></p><h4 id="超卖问题" tabindex="-1"><a class="header-anchor" href="#超卖问题"><span>超卖问题</span></a></h4><p>在高并发的时候会出现超卖情况，可以通过乐观锁解决。</p><p><img src="https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718174704.png" alt="image.png"></p><p>这里只需要在 update 的时候再去访问一下库存，看看跟之前的是否一样，这就实现了一个乐观锁。这样避免了问题，但是这样会浪费很多请求，导致请求失败率大大增加。优化方法是访问库存只需要判断库存是否大于 0 即可</p><h4 id="一人一单" tabindex="-1"><a class="header-anchor" href="#一人一单"><span>一人一单</span></a></h4><p>这里没办法采用乐观锁了，因为我们做的是查询操作，没办法更新值。这里只能用悲观锁。</p><p>悲观锁锁在什么位置是也是个大问题。</p>',105)]))}const g=e(s,[["render",r]]),m=JSON.parse('{"path":"/article/redis-note/","title":"黑马程序员 | Redis笔记","lang":"zh-CN","frontmatter":{"title":"黑马程序员 | Redis笔记","createTime":"2025/07/17 11:49:23","permalink":"/article/redis-note/","description":"Redis 基础篇 数据类型与命令 数据类型 Redis 是个键值数据库，一般来说 Key 是 String 类型，Value 却多种多样： 前五种基本类型，后三种特殊类型。 Key 的层级格式 有个问题：redis 里面没有表这个概念，那么如何区分员工 id 和商品 id 呢？ 项目名:业务名:类型:id Key 通过 : 形成层级。如果 value...","head":[["meta",{"property":"og:url","content":"https://github.com/MrSibe/MrSibe.github.io/article/redis-note/"}],["meta",{"property":"og:site_name","content":"西贝的博客"}],["meta",{"property":"og:title","content":"黑马程序员 | Redis笔记"}],["meta",{"property":"og:description","content":"Redis 基础篇 数据类型与命令 数据类型 Redis 是个键值数据库，一般来说 Key 是 String 类型，Value 却多种多样： 前五种基本类型，后三种特殊类型。 Key 的层级格式 有个问题：redis 里面没有表这个概念，那么如何区分员工 id 和商品 id 呢？ 项目名:业务名:类型:id Key 通过 : 形成层级。如果 value..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250716222752.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-09-14T03:18:42.000Z"}],["meta",{"property":"article:modified_time","content":"2025-09-14T03:18:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"黑马程序员 | Redis笔记\\",\\"image\\":[\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250716222752.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250716225506.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717102503.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103122.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103242.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103313.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103443.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103530.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103616.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717103638.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717104453.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717104734.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111143.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111343.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717111437.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717112018.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717112047.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113627.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113719.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113922.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717113959.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717114037.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717142948.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717151142.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250717180155.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718100836.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718113615.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718113850.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114056.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114201.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718114446.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718122231.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718122504.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718124422.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132634.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132824.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718132844.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718151108.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718154008.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718154601.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718163335.png\\",\\"https://raw.githubusercontent.com/MrSibe/obsidian_images/main/20250718174704.png\\"],\\"dateModified\\":\\"2025-09-14T03:18:42.000Z\\",\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":5.06,"words":1517},"git":{"updatedTime":1757819922000,"contributors":[{"name":"xibei","username":"xibei","email":"15281741661@qq.com","commits":3,"avatar":"https://avatars.githubusercontent.com/xibei?v=4","url":"https://github.com/xibei"}]},"autoDesc":true,"filePathRelative":"computer/redis-note.md","categoryList":[{"id":"df53ca","sort":10002,"name":"computer"}]}');export{g as comp,m as data};
